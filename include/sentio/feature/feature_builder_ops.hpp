#pragma once
#include <vector>
#include <cmath>
#include <algorithm>

namespace sentio {

inline std::vector<float> fb_ident(const std::vector<float>& x){ return x; }

inline std::vector<float> fb_logret(const std::vector<float>& x){
  std::vector<float> y(x.size(), 0.f);
  for (size_t i=1;i<x.size();++i){
    float a = std::max(x[i],    1e-12f);
    float b = std::max(x[i-1],  1e-12f);
    y[i] = std::log(a) - std::log(b);
  }
  return y;
}

inline std::vector<float> fb_ema(const std::vector<float>& x, int p){
  std::vector<float> e(x.size());
  if (x.empty()) return e;
  float k = 2.f / (p + 1.f);
  e[0] = x[0];
  for (size_t i=1;i<x.size();++i) e[i] = k*x[i] + (1.f-k)*e[i-1];
  return e;
}

inline std::vector<float> fb_rsi(const std::vector<float>& x, int p=14){
  const size_t N=x.size();
  std::vector<float> out(N,0.f), up(N,0.f), dn(N,0.f);
  for (size_t i=1;i<N;++i){
    float d=x[i]-x[i-1]; up[i]=std::max(d,0.f); dn[i]=std::max(-d,0.f);
  }
  std::vector<float> ru(N,0.f), rd(N,0.f);
  if (N> (size_t)p){
    float su=0.f, sd=0.f;
    for (int i=1;i<=p;i++){ su+=up[i]; sd+=dn[i]; }
    ru[p]=su/p; rd[p]=sd/p;
    for (size_t i=p+1;i<N;++i){
      ru[i]=(ru[i-1]*(p-1)+up[i])/p;
      rd[i]=(rd[i-1]*(p-1)+dn[i])/p;
      float rs=(rd[i]>1e-12f)?(ru[i]/rd[i]):0.f;
      out[i]=100.f-100.f/(1.f+rs);
    }
  }
  return out;
}

inline std::vector<float> fb_zwin(const std::vector<float>& x, int w){
  const size_t N=x.size(); std::vector<float> out(N,0.f);
  if (N <= (size_t)w) return out;
  std::vector<double> s(N,0.0), s2(N,0.0);
  s[0]=x[0]; s2[0]=x[0]*x[0];
  for (size_t i=1;i<N;++i){ s[i]=s[i-1]+x[i]; s2[i]=s2[i-1]+x[i]*x[i]; }
  for (size_t i=w;i<N;++i){
    double su = s[i]-s[i-w], su2 = s2[i]-s2[i-w];
    double mu = su/w;
    double var = std::max(0.0, su2/w - mu*mu);
    float sd = (float)std::sqrt(var);
    out[i] = (sd>1e-8f) ? (float)((x[i]-mu)/sd) : 0.f;
  }
  return out;
}

} // namespace sentio
