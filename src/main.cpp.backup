#include "sentio/core.hpp"
#include "sentio/runner.hpp"
#include "sentio/temporal_analysis.hpp"
#include "sentio/csv_loader.hpp"
#include "sentio/symbol_table.hpp"
#include "sentio/profiling.hpp"
#include "sentio/data_resolver.hpp"
#include "sentio/base_strategy.hpp"
#include "sentio/all_strategies.hpp"
#include "sentio/feature_feeder.hpp"
#include "sentio/data_downloader.hpp"
#include "sentio/audit_validator.hpp"
#include "sentio/feature/feature_matrix.hpp"
#include "sentio/strategy_tfa.hpp"
#include "sentio/virtual_market.hpp"
#include "sentio/unified_strategy_tester.hpp"
#include "sentio/cli_helpers.hpp"

#include <iostream>
#include <unordered_map>
#include <vector>
#include <string>
#include <memory>
#include <cstdlib> // For std::exit
#include <sstream>
#include <ctime> // For std::time
#include <fstream> // For std::ifstream
#include <iomanip> // For std::setw, std::setprecision
#include <cmath> // For std::pow
#include <ATen/Parallel.h> // For LibTorch threading controls
#include <nlohmann/json.hpp>


static bool verify_series_alignment(const sentio::SymbolTable& ST,
                                    const std::vector<std::vector<sentio::Bar>>& series,
                                    int base_sid){
    const auto& base = series[base_sid];
    if (base.empty()) return false;
    const size_t N = base.size();
    bool ok = true;
    for (size_t sid = 0; sid < series.size(); ++sid) {
        if (sid == (size_t)base_sid) continue;
        const auto& s = series[sid];
        if (s.empty()) continue; // allow missing non-base
        if (s.size() != N) {
            std::cerr << "FATAL: Alignment check failed: " << ST.get_symbol((int)sid)
                      << " bars=" << s.size() << " != base(" << ST.get_symbol(base_sid)
                      << ") bars=" << N << "\n";
            ok = false;
            continue;
        }
        size_t mism=0; for (size_t i=0;i<N;i++){ if (s[i].ts_utc_epoch != base[i].ts_utc_epoch) { mism++; if (mism<3) {
            std::cerr << "  ts mismatch["<<i<<"] " << s[i].ts_utc_epoch << " vs base " << base[i].ts_utc_epoch << "\n"; }
        } }
        if (mism>0) {
            std::cerr << "FATAL: Alignment check failed: " << ST.get_symbol((int)sid)
                      << " has " << mism << " timestamp mismatches vs base (first shown above).\n";
            ok = false;
        }
    }
    if (!ok) {
        std::cerr << "Hint: Use aligned CSVs or run tools/align_bars.py to generate aligned datasets.\n";
    }
    return ok;
}

static void load_strategy_config_if_any(const std::string& strategy_name, sentio::RunnerCfg& cfg){
    try {
        std::string lower = strategy_name;
        for (auto& c : lower) c = std::tolower(c);
        std::string path = "configs/strategies/" + lower + ".json";
        std::ifstream f(path);
        if (!f.good()) return;
        nlohmann::json j; f >> j;
        // params
        if (j.contains("params") && j["params"].is_object()){
            for (auto it = j["params"].begin(); it != j["params"].end(); ++it){
                cfg.strategy_params[it.key()] = std::to_string(it.value().get<double>());
            }
        }
        // router overrides
        if (j.contains("router")){
            auto r = j["router"];
            if (r.contains("ire_min_conf_strong_short")) cfg.router.ire_min_conf_strong_short = r["ire_min_conf_strong_short"].get<double>();
            if (r.contains("min_signal_strength")) cfg.router.min_signal_strength = r["min_signal_strength"].get<double>();
            if (r.contains("signal_multiplier"))   cfg.router.signal_multiplier   = r["signal_multiplier"].get<double>();
            if (r.contains("max_position_pct"))    cfg.router.max_position_pct    = r["max_position_pct"].get<double>();
            if (r.contains("min_shares"))          cfg.router.min_shares          = r["min_shares"].get<double>();
            if (r.contains("lot_size"))            cfg.router.lot_size            = r["lot_size"].get<double>();
            if (r.contains("base_symbol"))         cfg.router.base_symbol         = r["base_symbol"].get<std::string>();
            if (r.contains("bull3x"))              cfg.router.bull3x              = r["bull3x"].get<std::string>();
            if (r.contains("bear3x"))              cfg.router.bear3x              = r["bear3x"].get<std::string>();
            // Note: bear1x (PSQ) removed - moderate sell signals now use SHORT QQQ
        }
        // sizer overrides
        if (j.contains("sizer")){
            auto s = j["sizer"];
            if (s.contains("fractional_allowed")) cfg.sizer.fractional_allowed = s["fractional_allowed"].get<bool>();
            if (s.contains("min_notional"))       cfg.sizer.min_notional       = s["min_notional"].get<double>();
            if (s.contains("max_leverage"))       cfg.sizer.max_leverage       = s["max_leverage"].get<double>();
            if (s.contains("max_position_pct"))   cfg.sizer.max_position_pct   = s["max_position_pct"].get<double>();
            if (s.contains("volatility_target"))  cfg.sizer.volatility_target  = s["volatility_target"].get<double>();
            if (s.contains("allow_negative_cash"))cfg.sizer.allow_negative_cash= s["allow_negative_cash"].get<bool>();
            if (s.contains("vol_lookback_days"))  cfg.sizer.vol_lookback_days  = s["vol_lookback_days"].get<int>();
            if (s.contains("cash_reserve_pct"))   cfg.sizer.cash_reserve_pct   = s["cash_reserve_pct"].get<double>();
        }
    } catch (...) {
        // ignore config errors
    }
}

// Strategy registration is now handled by StrategyRegistry::load_from_config()
// This eliminates code duplication and allows dynamic strategy configuration


void usage() {
    std::cout << "Usage: sentio_cli <command> [options]\n\n"
              << "STRATEGY TESTING:\n"
              << "  strattest <strategy> <symbol> [options]    Unified strategy robustness testing\n"
              << "\n"
              << "DATA MANAGEMENT:\n"
              << "  download <symbol> [options]               Download historical data from Polygon.io\n"
              << "  probe                                     Show data availability and system status\n"
              << "\n"
              << "DEVELOPMENT & VALIDATION:\n"
              << "  audit-validate                            Validate strategies with audit system\n"
              << "\n"
              << "Global Options:\n"
              << "  --help, -h                                Show command-specific help\n"
              << "  --verbose, -v                             Enable verbose output\n"
              << "  --output <format>                         Output format: console|json|csv\n"
              << "\n"
              << "Examples:\n"
              << "  sentio_cli strattest momentum QQQ --mode hybrid --duration 1w\n"
              << "  sentio_cli strattest ire QQQ --comprehensive --stress-test\n"
              << "  sentio_cli download QQQ --period 3y\n"
              << "  sentio_cli probe\n"
              << "\n"
              << "Use 'sentio_cli <command> --help' for command-specific options.\n"
              << std::endl;
}

int main(int argc, char* argv[]) {
    // Configure LibTorch threading to prevent oversubscription (disabled for audit commands)
    // at::set_num_threads(1);         // intra-op
    // at::set_num_interop_threads(1); // inter-op
    
    // Initialize strategies using factory pattern
    if (!sentio::initialize_strategies()) {
        std::cerr << "Warning: Failed to initialize strategies" << std::endl;
    }
    
    if (argc < 2) {
        usage();
        return 1;
    }

    // Parse arguments using CLI helpers
    auto args = sentio::CLIHelpers::parse_arguments(argc, argv);
    std::string command = args.command;
    
    // Handle global help
    if (command.empty() || (args.help_requested && command.empty())) {
        usage();
        return 0;
    }
    
    if (command == "strattest") {
        if (args.help_requested) {
            sentio::CLIHelpers::print_help("strattest", 
                "sentio_cli strattest <strategy> <symbol> [options]",
                {
                    "--mode <mode>              Simulation mode: monte-carlo|historical|ai-regime|hybrid (default: hybrid)",
                    "--simulations <n>          Number of simulations (default: 50)",
                    "--duration <period>        Test duration: 1h, 4h, 1d, 5d, 1w, 1m (default: 5d)",
                    "--historical-data <file>   Historical data file (auto-detect if not specified)",
                    "--regime <regime>          Market regime: normal|volatile|trending|bear|bull (default: normal)",
                    "--stress-test              Enable stress testing scenarios",
                    "--regime-switching         Test across multiple market regimes",
                    "--liquidity-stress         Simulate low liquidity conditions",
                    "--alpaca-fees              Use Alpaca fee structure (default: true)",
                    "--alpaca-limits            Apply Alpaca position/order limits",
                    "--confidence <level>       Confidence level: 90|95|99 (default: 95)",
                    "--output <format>          Output format: console|json|csv (default: console)",
                    "--save-results <file>      Save detailed results to file",
                    "--benchmark <symbol>       Benchmark symbol (default: SPY)",
                    "--quick                    Quick mode: fewer simulations, faster execution",
                    "--comprehensive            Comprehensive mode: extensive testing scenarios",
                    "--params <json>            Strategy parameters as JSON string (default: '{}')"
                },
                {
                    "sentio_cli strattest momentum QQQ --mode hybrid --duration 1w",
                    "sentio_cli strattest ire QQQ --comprehensive --stress-test",
                    "sentio_cli strattest momentum QQQ --mode monte-carlo --simulations 100",
                    "sentio_cli strattest ire SPY --mode ai-regime --regime volatile"
                });
            return 0;
        }
        
        if (!sentio::CLIHelpers::validate_required_args(args, 2, 
            "sentio_cli strattest <strategy> <symbol> [options]")) {
            return 1;
        }
        
        std::string strategy_name = args.positional_args[0];
        std::string symbol = args.positional_args[1];
        
        // Validate inputs
        if (!sentio::CLIHelpers::is_valid_strategy_name(strategy_name)) {
            sentio::CLIHelpers::print_error("Invalid strategy name: " + strategy_name);
            return 1;
        }
        
        if (!sentio::CLIHelpers::is_valid_symbol(symbol)) {
            sentio::CLIHelpers::print_error("Invalid symbol: " + symbol);
            return 1;
        }
        
        // Build test configuration
        sentio::UnifiedStrategyTester::TestConfig config;
        config.strategy_name = strategy_name;
        config.symbol = symbol;
        
        // Parse options
        std::string mode_str = sentio::CLIHelpers::get_option(args, "mode", "hybrid");
        config.mode = sentio::UnifiedStrategyTester::parse_test_mode(mode_str);
        
        config.simulations = sentio::CLIHelpers::get_int_option(args, "simulations", 50);
        config.duration = sentio::CLIHelpers::get_option(args, "duration", "5d");
        config.historical_data_file = sentio::CLIHelpers::get_option(args, "historical-data");
        config.regime = sentio::CLIHelpers::get_option(args, "regime", "normal");
        
        config.stress_test = sentio::CLIHelpers::get_flag(args, "stress-test");
        config.regime_switching = sentio::CLIHelpers::get_flag(args, "regime-switching");
        config.liquidity_stress = sentio::CLIHelpers::get_flag(args, "liquidity-stress");
        
        config.alpaca_fees = !sentio::CLIHelpers::get_flag(args, "no-alpaca-fees"); // Default true
        config.alpaca_limits = sentio::CLIHelpers::get_flag(args, "alpaca-limits");
        config.paper_validation = sentio::CLIHelpers::get_flag(args, "paper-validation");
        
        int confidence_pct = sentio::CLIHelpers::get_int_option(args, "confidence", 95);
        config.confidence_level = confidence_pct / 100.0;
        
        config.output_format = sentio::CLIHelpers::get_option(args, "output", "console");
        config.save_results_file = sentio::CLIHelpers::get_option(args, "save-results");
        config.benchmark_symbol = sentio::CLIHelpers::get_option(args, "benchmark", "SPY");
        
        config.quick_mode = sentio::CLIHelpers::get_flag(args, "quick");
        config.comprehensive_mode = sentio::CLIHelpers::get_flag(args, "comprehensive");
        
        config.params_json = sentio::CLIHelpers::get_option(args, "params", "{}");
        
        // Adjust simulations based on mode flags
        if (config.quick_mode && config.simulations == 50) {
            config.simulations = 20;
        } else if (config.comprehensive_mode && config.simulations == 50) {
            config.simulations = 100;
        }
        
        // Run unified strategy test
        try {
            sentio::UnifiedStrategyTester tester;
            auto report = tester.run_comprehensive_test(config);
            
            // Display results
            if (config.output_format == "console") {
                tester.print_robustness_report(report, config);
            } else {
                // Save to file or output in other formats
                if (!config.save_results_file.empty()) {
                    if (tester.save_report(report, config, config.save_results_file, config.output_format)) {
                        std::cout << "Results saved to: " << config.save_results_file << std::endl;
                    } else {
                        std::cerr << "Failed to save results to: " << config.save_results_file << std::endl;
                        return 1;
                    }
                }
            }
            
            // Return deployment readiness as exit code (0 = ready, 1 = not ready)
            return report.ready_for_deployment ? 0 : 1;
            
        } catch (const std::exception& e) {
            std::cerr << "Error running strategy test: " << e.what() << std::endl;
            return 1;
        }
        
    } else if (command == "probe") {
        std::cout << "=== SENTIO SYSTEM PROBE ===\n\n";
        
        // Show available strategies
        std::cout << "📊 Available Strategies (" << sentio::StrategyFactory::instance().get_available_strategies().size() << " total):\n";
        std::cout << "=====================\n";
        for (const auto& strategy_name : sentio::StrategyFactory::instance().get_available_strategies()) {
            std::cout << "  • " << strategy_name << "\n";
        }
        std::cout << "\n";
        
        // Helper function to get file info
        auto get_file_info = [](const std::string& path) -> std::pair<bool, std::pair<std::string, std::string>> {
            std::ifstream file(path);
            if (!file.good()) {
                return {false, {"", ""}};
            }
            
            std::string line;
            std::getline(file, line); // Skip header
            
            std::string start_time = "N/A", end_time = "N/A";
            if (std::getline(file, line)) {
                std::istringstream iss(line);
                std::getline(iss, start_time, ',');
                
                // Find last valid data line (skip any trailing header lines)
                std::string current_line = line;
                while (std::getline(file, line)) {
                    // Skip lines that start with "timestamp" (trailing headers in aligned files)
                    if (line.find("timestamp,") != 0 && !line.empty()) {
                        current_line = line;
                    }
                }
                
                if (!current_line.empty() && current_line.find("timestamp,") != 0) {
                    std::istringstream last_iss(current_line);
                    std::getline(last_iss, end_time, ',');
                }
            }
            file.close();
            return {true, {start_time, end_time}};
        };
        
        // Helper function to count bars
        auto count_bars = [](const std::string& path) -> int {
            std::ifstream file(path);
            if (!file.good()) return 0;
            
            int count = 0;
            std::string line;
            while (std::getline(file, line)) {
                count++;
            }
            return count > 0 ? count - 1 : 0; // Exclude header
        };
        
        // Check data availability for QQQ family (our main trading symbols)
        std::cout << "📈 Data Availability Analysis:\n";
        std::cout << "==============================\n";
        
        std::vector<std::string> symbols = {"QQQ", "TQQQ", "SQQQ"};
        
        // Check daily data
        std::cout << "\n🗓️  DAILY DATA (Historical):\n";
        std::cout << "----------------------------\n";
        bool daily_aligned = true;
        int daily_bar_count = -1;
        
        for (const auto& symbol : symbols) {
            std::string daily_csv = "data/equities/daily/" + symbol + ".csv";
            std::string daily_aligned_csv = "data/equities/daily/" + symbol + "_ALIGNED.csv";
            
            auto [daily_exists, daily_times] = get_file_info(daily_csv);
            auto [aligned_exists, aligned_times] = get_file_info(daily_aligned_csv);
            
            std::cout << symbol << ":\n";
            
            if (daily_exists) {
                int bars = count_bars(daily_csv);
                std::cout << "  📄 Raw CSV: AVAILABLE (" << bars << " bars)\n";
                std::cout << "     Period: " << daily_times.first << " → " << daily_times.second << "\n";
                
                if (daily_bar_count == -1) daily_bar_count = bars;
                else if (daily_bar_count != bars) daily_aligned = false;
            } else {
                std::cout << "  📄 Raw CSV: MISSING\n";
                daily_aligned = false;
            }
            
            if (aligned_exists) {
                int aligned_bars = count_bars(daily_aligned_csv);
                std::cout << "  🔗 Aligned CSV: AVAILABLE (" << aligned_bars << " bars)\n";
                std::cout << "     Period: " << aligned_times.first << " → " << aligned_times.second << "\n";
            } else {
                std::cout << "  🔗 Aligned CSV: MISSING\n";
            }
            std::cout << "\n";
        }
        
        // Check minute data
        std::cout << "⏱️  MINUTE DATA (Recent):\n";
        std::cout << "-------------------------\n";
        bool minute_aligned = true;
        int minute_aligned_bar_count = -1;
        
        for (const auto& symbol : symbols) {
            std::string minute_csv = "data/equities/" + symbol + "_NH.csv";
            std::string minute_aligned_csv = "data/equities/" + symbol + "_NH_ALIGNED.csv";
            
            auto [minute_exists, minute_times] = get_file_info(minute_csv);
            auto [aligned_exists, aligned_times] = get_file_info(minute_aligned_csv);
            
            std::cout << symbol << ":\n";
            
            if (minute_exists) {
                int bars = count_bars(minute_csv);
                std::cout << "  📄 Raw CSV: AVAILABLE (" << bars << " bars)\n";
                std::cout << "     Period: " << minute_times.first << " → " << minute_times.second << "\n";
            } else {
                std::cout << "  📄 Raw CSV: MISSING\n";
            }
            
            if (aligned_exists) {
                int aligned_bars = count_bars(minute_aligned_csv);
                std::cout << "  🔗 Aligned CSV: AVAILABLE (" << aligned_bars << " bars)\n";
                std::cout << "     Period: " << aligned_times.first << " → " << aligned_times.second << "\n";
                
                // Check alignment based on aligned files, not raw files
                if (minute_aligned_bar_count == -1) minute_aligned_bar_count = aligned_bars;
                else if (minute_aligned_bar_count != aligned_bars) minute_aligned = false;
            } else {
                std::cout << "  🔗 Aligned CSV: MISSING\n";
                minute_aligned = false;
            }
            std::cout << "\n";
        }
        
        // Check binary cache files
        std::cout << "💾 Binary Cache Files:\n";
        std::cout << "----------------------\n";
        for (const auto& symbol : symbols) {
            std::string bin_path = "data/equities/" + symbol + ".bin";
            std::ifstream bin_file(bin_path);
            if (bin_file.good()) {
                bin_file.seekg(0, std::ios::end);
                size_t size = bin_file.tellg();
                std::cout << "  " << symbol << ".bin: AVAILABLE (" << (size / 1024) << " KB)\n";
                bin_file.close();
            } else {
                std::cout << "  " << symbol << ".bin: MISSING\n";
            }
        }
        
        // Alignment status summary
        std::cout << "\n🔍 Data Alignment Status:\n";
        std::cout << "=========================\n";
        
        if (daily_aligned && daily_bar_count > 0) {
            std::cout << "  ✅ Daily data: ALIGNED (" << daily_bar_count << " bars each)\n";
        } else {
            std::cout << "  ❌ Daily data: NOT ALIGNED or missing\n";
        }
        
        if (minute_aligned && minute_aligned_bar_count > 0) {
            std::cout << "  ✅ Minute data: ALIGNED (" << minute_aligned_bar_count << " bars each)\n";
        } else {
            std::cout << "  ❌ Minute data: NOT ALIGNED or missing\n";
        }
        
        // Recommendations
        std::cout << "\n💡 Recommendations:\n";
        std::cout << "===================\n";
        
        if (!daily_aligned) {
            std::cout << "  📋 Run: python tools/align_bars.py --qqq data/equities/daily/QQQ.csv --tqqq data/equities/daily/TQQQ.csv --sqqq data/equities/daily/SQQQ.csv\n";
        }
        
        if (!minute_aligned) {
            std::cout << "  📋 Run: python tools/align_bars.py --qqq data/equities/QQQ_NH.csv --tqqq data/equities/TQQQ_NH.csv --sqqq data/equities/SQQQ_NH.csv\n";
        }
        
        if (daily_aligned && minute_aligned) {
            std::cout << "  🎉 All data is properly aligned and ready for strategy testing!\n";
            std::cout << "  📋 Ready to run: ./build/sentio_cli tpatest QQQ --strategy-all\n";
        }
        
        std::cout << "\n";
        return 0;
    }
    
    if (command == "tpatest") {
        if (argc < 3) {
            std::cout << "Usage: sentio_cli tpatest <symbol> [--strategy <name>] [--strategy-all] [--params <k=v,...>] [--quarters <n>] [--weeks <n>] [--days <n>]\n";
            return 1;
        }
        
        std::string base_symbol = argv[2];
        std::string strategy_name = "TFA";
        std::unordered_map<std::string, std::string> strategy_params;
        int num_quarters = 0; // default: all data
        int num_weeks = 0;
        int num_days = 0;
        bool strategy_all = false;
        
        for (int i = 3; i < argc; i++) {
            std::string arg = argv[i];
            if (arg == "--strategy" && i + 1 < argc) {
                strategy_name = argv[++i];
            } else if (arg == "--strategy-all") {
                strategy_all = true;
            } else if (arg == "--params" && i + 1 < argc) {
                std::string params_str = argv[++i];
                std::stringstream ss(params_str);
                std::string pair;
                while (std::getline(ss, pair, ',')) {
                    size_t eq_pos = pair.find('=');
                    if (eq_pos != std::string::npos) {
                        strategy_params[pair.substr(0, eq_pos)] = pair.substr(eq_pos + 1);
                    }
                }
            } else if (arg == "--quarters" && i + 1 < argc) {
                num_quarters = std::stoi(argv[++i]);
            } else if (arg == "--weeks" && i + 1 < argc) {
                num_weeks = std::stoi(argv[++i]);
            } else if (arg == "--days" && i + 1 < argc) {
                num_days = std::stoi(argv[++i]);
            }
        }
        
        sentio::SymbolTable ST;
        std::vector<std::vector<sentio::Bar>> series;
        std::vector<std::string> symbols_to_load = {base_symbol};
        if (base_symbol == "QQQ") {
            symbols_to_load.push_back("TQQQ");
            symbols_to_load.push_back("SQQQ");
            // PSQ removed from family - moderate sell signals now use SHORT QQQ
        }

        std::cout << "Loading data for symbols: ";
        for(const auto& sym : symbols_to_load) std::cout << sym << " ";
        std::cout << std::endl;

        for (const auto& sym : symbols_to_load) {
            std::vector<sentio::Bar> bars;
            std::string data_path = sentio::resolve_csv(sym);
            
            if (!sentio::load_csv(data_path, bars)) {
                std::cerr << "ERROR: Failed to load data for " << sym << " from " << data_path << std::endl;
                continue;
            }
            std::cout << " -> Loaded " << bars.size() << " bars for " << sym << std::endl;
            
            int symbol_id = ST.intern(sym);
            if (static_cast<size_t>(symbol_id) >= series.size()) {
                series.resize(symbol_id + 1);
            }
            series[symbol_id] = std::move(bars);
        }
        
        int base_symbol_id = ST.get_id(base_symbol);
        if (series.empty() || series[base_symbol_id].empty()) {
            std::cerr << "FATAL: No data loaded for base symbol " << base_symbol << std::endl;
            return 1;
        }

        // Report data period and bars for transparency
        auto& base_bars2 = series[base_symbol_id];
        auto fmt_date2 = [](std::int64_t epoch_sec){
            std::time_t tt = static_cast<std::time_t>(epoch_sec);
            std::tm tm{}; gmtime_r(&tt, &tm);
            char buf[32]; std::strftime(buf, sizeof(buf), "%Y-%m-%d", &tm); return std::string(buf);
        };
        std::int64_t min_ts2 = base_bars2.front().ts_utc_epoch;
        std::int64_t max_ts2 = base_bars2.back().ts_utc_epoch;
        std::size_t   n_bars2 = base_bars2.size();
        double span_days2 = double(max_ts2 - min_ts2) / (24.0*3600.0);
        std::cout << "Data period: " << fmt_date2(min_ts2) << " → " << fmt_date2(max_ts2)
                  << " (" << std::fixed << std::setprecision(1) << span_days2 << " days)\n";
        std::cout << "Bars(" << base_symbol << "): " << n_bars2 << "\n";
        if ((max_ts2 - min_ts2) < (365LL*24LL*3600LL)) {
            std::cerr << "WARNING: Data period is shorter than 1 year. Results may be unrepresentative.\n";
        }

        // Alignment check (all loaded symbols must align to base timestamps)
        if (!verify_series_alignment(ST, series, base_symbol_id)) {
            std::cerr << "FATAL: Data alignment check failed. Aborting TPA test." << std::endl;
            return 1;
        }

        // Load cached features for ML strategies for massive performance improvement
        if (strategy_name == "TFA" || strategy_name == "tfa") {
            std::string feature_file = "data/" + base_symbol + "_RTH_features.csv";
            std::cout << "Loading pre-computed features from: " << feature_file << std::endl;
            if (sentio::FeatureFeeder::load_feature_cache(feature_file)) {
                sentio::FeatureFeeder::use_cached_features(true);
                std::cout << "✅ Cached features loaded successfully - MASSIVE speed improvement enabled!" << std::endl;
            } else {
                std::cout << "⚠️  Failed to load cached features - falling back to real-time calculation" << std::endl;
            }
        } else if (strategy_name == "kochi_ppo") {
            std::string feature_file = "data/" + base_symbol + "_KOCHI_features.csv";
            std::cout << "Loading pre-computed KOCHI features from: " << feature_file << std::endl;
            if (sentio::FeatureFeeder::load_feature_cache(feature_file)) {
                sentio::FeatureFeeder::use_cached_features(true);
                std::cout << "✅ KOCHI cached features loaded successfully" << std::endl;
            } else {
                std::cerr << "❌ KOCHI feature cache missing; cannot proceed for kochi_ppo strategy." << std::endl;
                return 1;
            }
        }

        // Merge defaults from configs/<strategy>.json (overridden by CLI params)
        sentio::RunnerCfg tmp_cfg2; tmp_cfg2.strategy_name = strategy_name;
        load_strategy_config_if_any(strategy_name, tmp_cfg2);
        for (const auto& kv : tmp_cfg2.strategy_params){ if (!strategy_params.count(kv.first)) strategy_params[kv.first] = kv.second; }
        sentio::RunnerCfg cfg;
        cfg.strategy_name = strategy_name;
        cfg.strategy_params = strategy_params;
        cfg.audit_level = sentio::AuditLevel::Full;
        cfg.snapshot_stride = 100;
        // **FIX**: Apply full router and sizer config from JSON
        cfg.router = tmp_cfg2.router;
        cfg.sizer = tmp_cfg2.sizer;
        
        sentio::TemporalAnalysisConfig temporal_cfg;
        temporal_cfg.num_quarters = num_quarters;
        temporal_cfg.num_weeks = num_weeks;
        temporal_cfg.num_days = num_days;
        temporal_cfg.print_detailed_report = true;
        
        // Determine which strategies to test
        std::vector<std::string> strategies_to_test;
        if (strategy_all) {
            strategies_to_test = sentio::StrategyFactory::instance().get_available_strategies();
            std::cout << "\nRunning TPA (Temporal Performance Analysis) Test for ALL strategies..." << std::endl;
            std::cout << "Found " << strategies_to_test.size() << " registered strategies" << std::endl;
        } else {
            strategies_to_test = {strategy_name};
            std::cout << "\nRunning TPA (Temporal Performance Analysis) Test..." << std::endl;
        }
        
        // Test each strategy
        for (size_t i = 0; i < strategies_to_test.size(); ++i) {
            const std::string& current_strategy = strategies_to_test[i];
            
            // **STRATEGY ISOLATION**: Reset all shared state before each strategy
            sentio::FeatureFeeder::reset_all_state();
            
            if (strategy_all) {
                std::cout << "\n" << std::string(60, '=') << std::endl;
                std::cout << "STRATEGY " << (i + 1) << "/" << strategies_to_test.size() << ": " << current_strategy << std::endl;
                std::cout << std::string(60, '=') << std::endl;
            } else {
                std::cout << "Strategy: " << current_strategy;
            }
            
            if (num_days > 0) {
                std::cout << ", Days: " << num_days;
            } else if (num_weeks > 0) {
                std::cout << ", Weeks: " << num_weeks;
            } else if (num_quarters > 0) {
                std::cout << ", Quarters: " << num_quarters;
            } else {
                std::cout << ", Full Dataset";
            }
            std::cout << std::endl;
            
            // Update config for current strategy
            cfg.strategy_name = current_strategy;
            
            // Load cached features for ML strategies
            if (current_strategy == "TFA" || current_strategy == "tfa") {
                std::string feature_file = "data/" + base_symbol + "_RTH_features.csv";
                std::cout << "Loading pre-computed features from: " << feature_file << std::endl;
                if (sentio::FeatureFeeder::load_feature_cache(feature_file)) {
                    sentio::FeatureFeeder::use_cached_features(true);
                    std::cout << "✅ Cached features loaded successfully - MASSIVE speed improvement enabled!" << std::endl;
                } else {
                    std::cout << "⚠️  Failed to load cached features - falling back to real-time calculation" << std::endl;
                }
            } else if (current_strategy == "kochi_ppo") {
                std::string feature_file = "data/" + base_symbol + "_KOCHI_features.csv";
                std::cout << "Loading pre-computed KOCHI features from: " << feature_file << std::endl;
                if (sentio::FeatureFeeder::load_feature_cache(feature_file)) {
                    sentio::FeatureFeeder::use_cached_features(true);
                    std::cout << "✅ KOCHI cached features loaded successfully" << std::endl;
                } else {
                    std::cerr << "❌ KOCHI feature cache missing; skipping kochi_ppo strategy." << std::endl;
                    continue;
                }
            }
            
            // Merge defaults from configs/<strategy>.json (overridden by CLI params)
            sentio::RunnerCfg tmp_cfg_current; tmp_cfg_current.strategy_name = current_strategy;
            load_strategy_config_if_any(current_strategy, tmp_cfg_current);
            for (const auto& kv : tmp_cfg_current.strategy_params){ if (!strategy_params.count(kv.first)) strategy_params[kv.first] = kv.second; }
            cfg.strategy_params = strategy_params;
            cfg.router = tmp_cfg_current.router;
            cfg.sizer = tmp_cfg_current.sizer;
            
            sentio::Tsc timer;
            timer.tic();
            auto summary = sentio::run_temporal_analysis(ST, series, base_symbol_id, cfg, temporal_cfg);
            double elapsed = timer.toc_sec();
            
            std::cout << "\nTPA test completed in " << elapsed << "s" << std::endl;
            
            if (temporal_cfg.print_detailed_report) {
                sentio::TemporalAnalyzer analyzer;
                // Set the correct period name based on the configuration
                if (num_days > 0) {
                    analyzer.set_period_name("day");
                } else if (num_weeks > 0) {
                    analyzer.set_period_name("week");
                } else if (num_quarters > 0) {
                    analyzer.set_period_name("quarter");
                } else {
                    analyzer.set_period_name("full period");
                }
                for (const auto& q : summary.quarterly_results) {
                    analyzer.add_quarterly_result(q);
                }
                analyzer.print_detailed_report();
            }
        }
        
        if (strategy_all) {
            std::cout << "\n" << std::string(60, '=') << std::endl;
            std::cout << "ALL STRATEGIES TESTED COMPLETED" << std::endl;
            std::cout << std::string(60, '=') << std::endl;
        }
        
    } else if (command == "audit-validate") {
        std::cout << "🔍 **STRATEGY-AGNOSTIC AUDIT VALIDATION**" << std::endl;
        std::cout << "Validating that all registered strategies work with the audit system..." << std::endl;
        std::cout << std::endl;
        
        // Run validation for all strategies
        auto results = sentio::AuditValidator::validate_all_strategies(50); // Test with 50 bars
        
        // Print comprehensive report
        sentio::AuditValidator::print_validation_report(results);
        
        // Return appropriate exit code
        bool all_passed = std::all_of(results.begin(), results.end(), 
                                     [](const auto& r) { return r.success; });
        return all_passed ? 0 : 1;
        
    } else if (command == "download") {
        if (argc < 3) {
            std::cout << "Usage: sentio_cli download <symbol> [--years <n>] [--months <n>] [--days <n>] [--timespan day|hour|minute] [--holidays]\n";
            std::cout << "\nDefaults: --years 3 --timespan minute --no-holidays\n";
            std::cout << "Examples:\n";
            std::cout << "  sentio_cli download QQQ                    # 3 years of minute data, no holidays\n";
            std::cout << "  sentio_cli download QQQ --days 30          # 30 days of minute data, no holidays\n";
            std::cout << "  sentio_cli download QQQ --timespan day     # 3 years of daily data, no holidays\n";
            std::cout << "  sentio_cli download QQQ --holidays         # 3 years of minute data, with holidays\n";
            std::cout << "\nNote: QQQ family automatically downloads TQQQ and SQQQ as well.\n";
            return 1;
        }
        
        std::string symbol = argv[2];
        int years = 3, months = 0, days = 0;  // Default: 3 years
        std::string timespan = "minute";      // Default: minute data
        bool exclude_holidays = true;         // Default: exclude holidays
        
        // Parse download options
        for (int i = 3; i < argc; i++) {
            std::string arg = argv[i];
            if (arg == "--years" && i + 1 < argc) {
                years = std::stoi(argv[++i]);
                months = 0; days = 0;  // Reset other periods
            } else if (arg == "--months" && i + 1 < argc) {
                months = std::stoi(argv[++i]);
                years = 0; days = 0;   // Reset other periods
            } else if (arg == "--days" && i + 1 < argc) {
                days = std::stoi(argv[++i]);
                years = 0; months = 0; // Reset other periods
            } else if (arg == "--timespan" && i + 1 < argc) {
                timespan = argv[++i];
                if (timespan != "day" && timespan != "hour" && timespan != "minute") {
                    std::cerr << "Error: Invalid timespan '" << timespan << "'. Use day, hour, or minute." << std::endl;
                    return 1;
                }
            } else if (arg == "--no-holidays") {
                exclude_holidays = true;
            } else if (arg == "--holidays") {
                exclude_holidays = false;
            }
        }
        
        // Download data using the extracted functionality
        bool success = sentio::download_symbol_data(symbol, years, months, days, timespan, 1, exclude_holidays);
        
        if (!success) {
            std::cerr << "❌ Download failed. Check the error messages above." << std::endl;
            return 1;
        }
        
        return 0;
        
    } else if (command == "test-models") {
        std::string strategy_name = "tfa";
        std::string data_file = "data/QQQ_RTH.csv";
        std::string start_date = "2023-01-01";
        std::string end_date = "2023-12-31";
        
        for (int i = 2; i < argc; i++) {
            std::string arg = argv[i];
            if (arg == "--strategy" && i + 1 < argc) {
                strategy_name = argv[++i];
            } else if (arg == "--data" && i + 1 < argc) {
                data_file = argv[++i];
            } else if (arg == "--start" && i + 1 < argc) {
                start_date = argv[++i];
            } else if (arg == "--end" && i + 1 < argc) {
                end_date = argv[++i];
            }
        }
        
        // Validate strategy name
        if (strategy_name != "tfa") {
            std::cerr << "ERROR: Strategy must be 'tfa'. Got: " << strategy_name << std::endl;
            return 1;
        }
        
        // Check if model exists
        std::string model_dir = "artifacts/TFA/v1";
        std::string model_path = model_dir + "/model.pt";
        std::string metadata_path = model_dir + "/metadata.json";
        
        if (!std::ifstream(model_path).good()) {
            std::cerr << "ERROR: Model not found at " << model_path << std::endl;
            std::cerr << "Please train the model first: python train_models.py" << std::endl;
            return 1;
        }
        
        if (!std::ifstream(metadata_path).good()) {
            std::cerr << "ERROR: Metadata not found at " << metadata_path << std::endl;
            return 1;
        }
        
        std::cout << "🧪 Testing " << strategy_name << " model..." << std::endl;
        std::cout << "📁 Model: " << model_path << std::endl;
        std::cout << "📊 Data: " << data_file << std::endl;
        std::cout << "📅 Period: " << start_date << " to " << end_date << std::endl;
        
        // Load data
        std::vector<sentio::Bar> bars;
        if (!sentio::load_csv(data_file, bars)) {
            std::cerr << "ERROR: Failed to load data from " << data_file << std::endl;
            return 1;
        }
        
        std::cout << "✅ Loaded " << bars.size() << " bars" << std::endl;
        
        // Load feature specification
        std::string feature_spec_path = "python/feature_spec.json";
        std::ifstream spec_file(feature_spec_path);
        if (!spec_file.good()) {
            std::cerr << "ERROR: Feature spec not found at " << feature_spec_path << std::endl;
            return 1;
        }
        
        std::string spec_json((std::istreambuf_iterator<char>(spec_file)), std::istreambuf_iterator<char>());
        std::cout << "✅ Loaded feature specification" << std::endl;
        
        // For now, let's skip the C++ feature builder and use a simple approach
        // We'll create dummy features to test the model loading and signal generation
        std::cout << "🔧 Creating dummy features for testing..." << std::endl;
        
        // Create a simple feature matrix with dummy data
        sentio::FeatureMatrix feature_matrix;
        feature_matrix.rows = std::min(100, static_cast<int>(bars.size()));
        feature_matrix.cols = 6; // close, logret, ema_20, ema_50, rsi_14, zlog_20
        feature_matrix.data.resize(feature_matrix.rows * feature_matrix.cols);
        
        // Fill with dummy features (just close prices for now)
        for (int i = 0; i < feature_matrix.rows; ++i) {
            int base_idx = i * feature_matrix.cols;
            feature_matrix.data[base_idx + 0] = static_cast<float>(bars[i].close); // close
            feature_matrix.data[base_idx + 1] = 0.0f; // logret
            feature_matrix.data[base_idx + 2] = static_cast<float>(bars[i].close); // ema_20
            feature_matrix.data[base_idx + 3] = static_cast<float>(bars[i].close); // ema_50
            feature_matrix.data[base_idx + 4] = 50.0f; // rsi_14
            feature_matrix.data[base_idx + 5] = 0.0f; // zlog_20
        }
        
        std::cout << "✅ Created dummy features: " << feature_matrix.rows << " rows x " << feature_matrix.cols << " cols" << std::endl;
        
        // Create TFA strategy instance
        std::unique_ptr<sentio::TFAStrategy> tfa_strategy = std::make_unique<sentio::TFAStrategy>();
        
        std::cout << "\n🧪 Testing " << strategy_name << " model with features..." << std::endl;
        
        // Feed features to strategy and test signal generation
        int signals_generated = 0;
        int total_bars = std::min(100, static_cast<int>(feature_matrix.rows)); // Test first 100 bars
        
        for (int i = 0; i < total_bars; ++i) {
            // Extract features for this bar
            std::vector<double> raw_features(feature_matrix.cols);
            for (int j = 0; j < feature_matrix.cols; ++j) {
                raw_features[j] = feature_matrix.data[i * feature_matrix.cols + j];
            }
            
            // Create a dummy bar for on_bar call
            sentio::Bar dummy_bar;
            if (i < static_cast<int>(bars.size())) {
                dummy_bar = bars[i];
            }
            
            sentio::StrategyCtx ctx;
            ctx.ts_utc_epoch = dummy_bar.ts_utc_epoch;
            ctx.instrument = "QQQ";
            ctx.is_rth = true;
            
            // Feed features to strategy and call on_bar
            if (tfa_strategy) {
                tfa_strategy->set_raw_features(raw_features);
                tfa_strategy->on_bar(ctx, dummy_bar);
                auto signal = tfa_strategy->latest();
                if (signal) {
                    signals_generated++;
                    std::cout << "Bar " << i << ": Signal generated - " 
                              << (signal->type == sentio::StrategySignal::Type::BUY ? "BUY" : 
                                  signal->type == sentio::StrategySignal::Type::SELL ? "SELL" : "HOLD")
                              << " (conf=" << signal->confidence << ")" << std::endl;
                }
            } else if (tfa_strategy) {
                tfa_strategy->set_raw_features(raw_features);
                tfa_strategy->on_bar(ctx, dummy_bar);
                auto signal = tfa_strategy->latest();
                if (signal) {
                    signals_generated++;
                    std::cout << "Bar " << i << ": Signal generated - " 
                              << (signal->type == sentio::StrategySignal::Type::BUY ? "BUY" : 
                                  signal->type == sentio::StrategySignal::Type::SELL ? "SELL" : "HOLD")
                              << " (conf=" << signal->confidence << ")" << std::endl;
                }
            }
        }
        
        std::cout << "\n📊 Test Results:" << std::endl;
        std::cout << "  Total bars tested: " << total_bars << std::endl;
        std::cout << "  Signals generated: " << signals_generated << std::endl;
        std::cout << "  Signal rate: " << (100.0 * signals_generated / total_bars) << "%" << std::endl;
        
        if (signals_generated == 0) {
            std::cout << "\n⚠️  WARNING: No signals generated! This could indicate:" << std::endl;
            std::cout << "  - Model confidence threshold too high" << std::endl;
            std::cout << "  - Feature window not ready" << std::endl;
            std::cout << "  - Model prediction issues" << std::endl;
            std::cout << "  - Check the diagnostic output above for details" << std::endl;
        } else {
            std::cout << "\n✅ Model is generating signals successfully!" << std::endl;
        }
        
    } else if (command == "vmtest") {
        if (argc < 4) {
            std::cout << "Usage: sentio_cli vmtest <strategy> <symbol> [--days <n>] [--hours <n>] [--simulations <n>] [--params <json>] [--historical-data <file>]\n";
            return 1;
        }
        
        std::string strategy_name = argv[2];
        std::string symbol = argv[3];
        int days = 30;
        int hours = 0;
        int simulations = 100;
        std::string params_json = "{}";
        std::string historical_data_file = "data/equities/" + symbol + "_RTH_NH.csv";
        
        for (int i = 4; i < argc; i++) {
            std::string arg = argv[i];
            if (arg == "--days" && i + 1 < argc) {
                days = std::stoi(argv[++i]);
            } else if (arg == "--hours" && i + 1 < argc) {
                hours = std::stoi(argv[++i]);
            } else if (arg == "--simulations" && i + 1 < argc) {
                simulations = std::stoi(argv[++i]);
            } else if (arg == "--params" && i + 1 < argc) {
                params_json = argv[++i];
            } else if (arg == "--historical-data" && i + 1 < argc) {
                historical_data_file = argv[++i];
            }
        }
        
        std::cout << "🚀 Starting Virtual Market Test (Fast Historical Bridge)..." << std::endl;
        std::cout << "📊 Strategy: " << strategy_name << std::endl;
        std::cout << "📈 Symbol: " << symbol << std::endl;
        std::cout << "⏱️  Duration: " << (hours > 0 ? std::to_string(hours) + " hours" : std::to_string(days) + " days") << std::endl;
        std::cout << "🎲 Simulations: " << simulations << std::endl;
        std::cout << "📊 Historical data: " << historical_data_file << std::endl;
        std::cout << "⚡ Using optimized historical patterns" << std::endl;
        
        // Convert days/hours to continuation minutes
        int continuation_minutes = hours > 0 ? hours * 60 : days * 390; // 390 minutes per trading day
        
        // Run fast historical test
        sentio::VirtualMarketEngine vm_engine;
        auto results = vm_engine.run_fast_historical_test(strategy_name, symbol, historical_data_file, 
                                                         continuation_minutes, simulations, params_json);
        
        std::cout << "\n✅ Virtual Market Test completed successfully" << std::endl;

    } else if (command == "marstest") {
        if (argc < 4) {
            std::cout << "Usage: sentio_cli marstest <strategy> <symbol> [--days <n>] [--simulations <n>] [--regime <regime>] [--params <json>]\n";
            return 1;
        }
        
        std::string strategy_name = argv[2];
        std::string symbol = argv[3];
        int days = 1; // Start with 1 day for MarS
        int simulations = 10; // Fewer simulations for MarS (more expensive)
        std::string market_regime = "normal";
        std::string params_json = "{}";
        
        for (int i = 4; i < argc; i++) {
            std::string arg = argv[i];
            if (arg == "--days" && i + 1 < argc) {
                days = std::stoi(argv[++i]);
            } else if (arg == "--simulations" && i + 1 < argc) {
                simulations = std::stoi(argv[++i]);
            } else if (arg == "--regime" && i + 1 < argc) {
                market_regime = argv[++i];
            } else if (arg == "--params" && i + 1 < argc) {
                params_json = argv[++i];
            }
        }
        
        std::cout << "🚀 Starting MarS Virtual Market Test..." << std::endl;
        std::cout << "📊 Strategy: " << strategy_name << std::endl;
        std::cout << "📈 Symbol: " << symbol << std::endl;
        std::cout << "⏱️  Duration: " << days << " days" << std::endl;
        std::cout << "🎲 Simulations: " << simulations << std::endl;
        std::cout << "🌊 Market Regime: " << market_regime << std::endl;
        std::cout << "🤖 Using MarS AI-powered market simulation" << std::endl;
        
        // Run MarS virtual market test
        sentio::VirtualMarketEngine vm_engine;
        auto results = vm_engine.run_mars_vm_test(strategy_name, symbol, days, simulations, market_regime, params_json);
        
        std::cout << "\n✅ MarS VM test completed successfully" << std::endl;

    } else if (command == "fasttest") {
        if (argc < 4) {
            std::cout << "Usage: sentio_cli fasttest <strategy> <symbol> [--historical-data <file>] [--continuation-minutes <n>] [--simulations <n>] [--params <json>]\n";
            return 1;
        }
        
        std::string strategy_name = argv[2];
        std::string symbol = argv[3];
        std::string historical_data_file = "data/equities/" + symbol + "_RTH_NH.csv";
        int continuation_minutes = 60;
        int simulations = 10;
        std::string params_json = "{}";
        
        for (int i = 4; i < argc; i++) {
            std::string arg = argv[i];
            if (arg == "--historical-data" && i + 1 < argc) {
                historical_data_file = argv[++i];
            } else if (arg == "--continuation-minutes" && i + 1 < argc) {
                continuation_minutes = std::stoi(argv[++i]);
            } else if (arg == "--simulations" && i + 1 < argc) {
                simulations = std::stoi(argv[++i]);
            } else if (arg == "--params" && i + 1 < argc) {
                params_json = argv[++i];
            }
        }
        
        std::cout << "⚡ Starting Fast Historical Test..." << std::endl;
        std::cout << "📊 Strategy: " << strategy_name << std::endl;
        std::cout << "📈 Symbol: " << symbol << std::endl;
        std::cout << "📊 Historical data: " << historical_data_file << std::endl;
        std::cout << "⏱️  Continuation: " << continuation_minutes << " minutes" << std::endl;
        std::cout << "🎲 Simulations: " << simulations << std::endl;
        std::cout << "🚀 Using optimized historical patterns" << std::endl;
        
        // Run fast historical test
        sentio::VirtualMarketEngine vm_engine;
        auto results = vm_engine.run_fast_historical_test(strategy_name, symbol, historical_data_file, 
                                                         continuation_minutes, simulations, params_json);
        
        std::cout << "\n✅ Fast historical test completed successfully" << std::endl;

    } else {
        usage();
        return 1;
    }
    
    return 0;
}
