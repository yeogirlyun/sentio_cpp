#include "sentio/runner.hpp"
#include "sentio/base_strategy.hpp"
#include "sentio/pricebook.hpp"
#include "sentio/metrics.hpp"
#include "sentio/sizer.hpp"
#include <iostream>
#include <memory>
#include <stdexcept>

namespace sentio {

RunResult run_backtest([[maybe_unused]] Auditor& au, const SymbolTable& ST, const std::vector<std::vector<Bar>>& series, 
                      int base_symbol_id, const RunnerCfg& cfg) {
    
    // 1. ============== INITIALIZATION ==============
    RunResult result{};
    auto strategy = StrategyFactory::instance().create_strategy(cfg.strategy_name);
    if (!strategy) {
        std::cerr << "FATAL: Could not create strategy '" << cfg.strategy_name << "'. Check registration." << std::endl;
        return result;
    }
    
    ParameterMap params;
    for (const auto& [key, value] : cfg.strategy_params) {
        try {
            params[key] = std::stod(value);
        } catch (...) { /* ignore */ }
    }
    strategy->set_params(params);

    Portfolio portfolio(ST.size());
    AdvancedSizer sizer;
    Pricebook pricebook(base_symbol_id, ST, series);
    
    std::vector<std::pair<std::string, double>> equity_curve;
    const auto& base_series = series[base_symbol_id];
    equity_curve.reserve(base_series.size());

    int total_fills = 0;
    int no_route_count = 0;
    int no_qty_count = 0;

    // 2. ============== MAIN EVENT LOOP ==============
    for (size_t i = 0; i < base_series.size(); ++i) {
        const auto& bar = base_series[i];
        pricebook.sync_to_base_i(i);
        
        StrategySignal sig = strategy->calculate_signal(base_series, i);
        
        if (sig.type != StrategySignal::Type::HOLD) {
            // Note: metadata not available in new StrategySignal structure
            
            auto route_decision = route(sig, cfg.router, ST.get_symbol(base_symbol_id));

            if (route_decision) {
                int instrument_id = ST.get_id(route_decision->instrument);
                if (instrument_id != -1) {
                    double instrument_price = pricebook.last_px[instrument_id];

                    if (instrument_price > 0) {
                        [[maybe_unused]] double current_equity = equity_mark_to_market(portfolio, pricebook.last_px);
                        
                        // **MODIFIED**: This is the core logic fix.
                        // We calculate the desired final position size, then determine the needed trade quantity.
                        double target_qty = sizer.calculate_target_quantity(portfolio, ST, pricebook.last_px, 
                                                                             route_decision->instrument, route_decision->target_weight, 
                                                                             series[instrument_id], cfg.sizer);
                        
                        double current_qty = portfolio.positions[instrument_id].qty;
                        double trade_qty = target_qty - current_qty; // The actual amount to trade

                        if (std::abs(trade_qty * instrument_price) > 1.0) { // Min trade notional $1
                            apply_fill(portfolio, instrument_id, trade_qty, instrument_price);
                            total_fills++; // **CRITICAL FIX**: Increment the fills counter
                        } else {
                            no_qty_count++;
                        }
                    }
                }
            } else {
                no_route_count++;
            }
        }
        
        // 3. ============== SNAPSHOT ==============
        if (i % cfg.snapshot_stride == 0 || i == base_series.size() - 1) {
            double current_equity = equity_mark_to_market(portfolio, pricebook.last_px);
            equity_curve.emplace_back(bar.ts_utc, current_equity);
        }
    }
    
    // 4. ============== METRICS & DIAGNOSTICS ==============
    strategy->get_diag().print(strategy->get_name().c_str());

    if (equity_curve.empty()) {
        return result;
    }
    
    // **CRITICAL FIX**: Pass the correct `total_fills` to the metrics calculator.
    auto summary = compute_metrics_day_aware(equity_curve, total_fills);

    result.final_equity = equity_curve.empty() ? 100000.0 : equity_curve.back().second;
    result.total_return = summary.ret_total * 100.0;
    result.sharpe_ratio = summary.sharpe;
    result.max_drawdown = summary.mdd * 100.0;
    result.total_fills = summary.trades;
    result.no_route = no_route_count;
    result.no_qty = no_qty_count;

    return result;
}

} // namespace sentio